# -*- coding: utf-8 -*-
"""
Created on Sun May 29 19:25:25 2016

@author: MaxHenger
"""

import numpy as np
import TrackLookup

def StringPad(name, value, decimals, length):
    valueString = str(round(value, decimals))

    dot = valueString.find('.', 0)

    if dot != -1:
        if len(valueString) - dot - 1 < decimals:
            valueString = valueString + ('0' * (decimals + 1 + dot - len(valueString)))

    if len(valueString) < length:
        valueString = ' ' * (length - len(valueString)) + valueString

    return name + valueString

def StringHeader(name, width, knot='+', hor='-', ver='|'):
    stringUpper = knot + ((width - 2) * hor) + knot
    stringCenter = ''

    if len(name) <= width - 4:
        remaining = int(width - 4 - len(name))

        if remaining % 2 == 0:
            stringCenter = ver + (' ' * int(remaining / 2 + 1)) + name + (' ' * int(remaining / 2 + 1)) + ver
        else:
            stringCenter = ver + (' ' * (int(remaining / 2) + 2)) + \
                name + (' ' * (int(remaining / 2) + 1)) + ver

    return stringUpper + '\n' + stringCenter + '\n' + stringUpper

def LoadAerodynamicData(dataCl, dataCd, tol=1e-15):
    # Load data from file
    dataCl = np.genfromtxt(dataCl, delimiter=';')
    dataCd = np.genfromtxt(dataCd, delimiter=';')

    # Check for consistency of dimensions
    if dataCl.shape[1] < 2:
        raise ValueError("Expected at least two columns in Cl data file")

    if dataCd.shape[1] < 2:
        raise ValueError("Expected at least two columns in Cd data file")

    if dataCl.shape[0] != dataCd.shape[0]:
        raise ValueError("Expected same number of rows in Cl as in Cd file")

    # Check for consistency of angles of attack
    for iAlpha in range(0, dataCl.shape[0]):
        if abs(dataCl[iAlpha, 0] - dataCd[iAlpha, 0]) > tol:
            raise ValueError('ClAlpha =', dataCl[iAlpha, 0], '!=',
                             'CdAlpha =', dataCd[iAlpha, 0], 'at index', iAlpha)

    # Create the lookup tables and return them
    return TrackLookup.Lookup1D(dataCl[:, 0], dataCl[:, 1]), \
        TrackLookup.Lookup1D(dataCd[:, 0], dataCd[:, 1])

def AdjustBiasMapIndividually(biasMap, amount, location, width, name):
    print('adjusting', name, 'bias by', round(amount, 3), 'at h', round(location, 1), 'km')

    if not biasMap.modifyCentered(amount, location, width):
        base = biasMap.getBaseBias()
        print('bias became negative, adjusting', name, 'base from',
            round(base, 3), 'to', round(base - amount, 3))

        biasMap.reset(base - amount)

    return biasMap.getBaseBias()

def AdjustBiasMapCommonly(biasMaps, amount, names):
    newBiases = [0] * len(biasMaps)

    for iMap in range(0, len(biasMaps)):
        curBias = biasMaps[i].getBaseBias()
        print('adjusting', names[i], 'bias from', round(curBias, 3),
            'to', round(curBias - amount, 3))

        newBiases[iMap] = curBias - amount
        biasMap.reset(newBiases[iMap])

    return newBiases

def Lerp(x1, y1, x2, y2, x):
    return y1 + (y2 - y1) / (x2 - x1) * (x - x1)

# TODO: REMOVE THIS LATER!
'''
# AngleOfAttackPowered will determine the angle of attack at which the vertical
# and horizontal acceleration of the aircraft will be zero in the case the
# provided propellor power is non-zero. This is done by using an iterative
# method that will come up with the angle of attack that lies closest to the
# desired angle of attack. Note that this angle of attack can be wrong and lie
# close to the limits of the lookup maps.
#
# Inputs:
#   - W: The weight of the aircraft in N
#   - S: The wing planform surface area in m^2
#   - Vinf: The freestream dynamic pressure in Pa
#   - P: The power that is being generated by the propellers
#   - inclination: The inclination of the propellers with respect to the body
#       in radians
#   - lookupCl: An instance of a TrackLookup class describing the relation
#       between the angle of attack and the lift coefficient
#   - lookupCd: An instance of a TrackLookup class describing the relation
#       beween the angle of attack and the drag coefficient
#   - numPoints: The number of points to evaluate during each iteration
#   - numIt: The number of iterations to perform
#   - epsilon: Number to use to compare final found angle of attack for validity
def AngleOfAttack(W, S, qInf, P, inclination, lookupCl, lookupCd, numPoints=15, numIt=16, epsilon=1e-2):
    alphaAbsMin = lookupCl.getPoints()[0][0]
    alphaMin = alphaAbsMin
    alphaAbsMax = lookupCl.getPoints()[0][-1]
    alphaMax = alphaAbsMax

    alphaRange = (alphaMax - alphaMin) / 2.0

    # lambda for angle calculator (returned in degrees)
    aoa = lambda W, q, S, alpha, lookupCl, lookupCd, inclination: (
        np.arctan2((W / (q * S) - lookupCl(alpha)), lookupCd(alpha)) -
        inclination) * 180.0 / np.pi

    alphaBest = 0

    # Perform the subdivision iterations
    for iIteration in range(0, numIt):
        # Calculate the initial values for the first angle of attack
        alpha = np.linspace(alphaMin, alphaMax, numPoints)

        deltaAlphaBest = abs(aoa(W, qInf, S, alpha[0], lookupCl,
            lookupCd, inclination) - alpha[0])
        alphaBest = alpha[0]

        # Calculate the remaining angles of attack and find the best one
        for iAlpha in range(1, numPoints):
            deltaAlpha = abs(aoa(W, qInf, S, alpha[iAlpha], lookupCl,
                lookupCd, inclination) - alpha[iAlpha])

            if deltaAlpha < deltaAlphaBest:
                deltaAlphaBest = deltaAlpha
                alphaBest = alpha[iAlpha]

        # Create a new range to process
        alphaRange /= 2.0
        alphaMin = max(alphaBest - alphaRange, alphaAbsMin)
        alphaMax = min(alphaBest + alphaRange, alphaAbsMax)

    # Check the final solution for validity
    print('aoa:', aoa(W, qInf, S, alphaBest, lookupCl, lookupCd, inclination))
    print('input:', alphaBest)
    print('diff:', abs(aoa(W, qInf, S, alphaBest, lookupCl, lookupCd, inclination) - alphaBest))
    print('epsilon:', epsilon)

    if (abs(aoa(W, qInf, S, alphaBest, lookupCl, lookupCd,
            inclination) - alphaBest)) > epsilon:
        # Final difference is too large
        return alphaBest, False

    return alphaBest, True
'''

def __TestLoadAerodynamicData__():
    Cl, Cd = LoadAerodynamicData("./data/aerodynamicPerformance/Cl.csv",
                                 "./data/aerodynamicPerformance/Cd.csv")

    ClPoints = Cl.getPoints()
    CdPoints = Cd.getPoints()

    for i in range(0, len(ClPoints[0])):
        print('alpha =', round(ClPoints[0][i], 4),
              ', Cl =', round(ClPoints[1][i], 4),
              ', Cd =', round(CdPoints[1][i], 4))

#__TestLoadAerodynamicData__()
