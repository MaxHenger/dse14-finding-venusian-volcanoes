__author__ = 'Stefan'
import numpy as np


def fuselagesize(V,L):#volume, cilinder length
    L=5.#length cilinder of fuselage
    V=6. #Volume in m3
    r=np.roots([4/3*np.pi,0,2*np.pi*L,-V])
    R=np.real(r[2])#fuselage radius for given length and volume
    tL=L+2*R #total length
    return R, tL

def fuselagemass(t,L,R,rhofuselage):
    Mcilinder=2*np.pi*R*L*t*rhofuselage
    Msphere=4*np.pi*R**2*t*rhofuselage
    fuselagemass=Mcilinder+Msphere
    return fuselagemass



#specificstrength=250000 #Nm/kg
#p=500000  #pressure difference in Pa
#stresses multiplied by t
#Cilinder
#Loopstress=p*R/t
#Longitudinalstress=p*R/2
#sphere
#t=0.001 #initial thickness
#Spherestress=p*R/2 #loop or longitudinal
#VMcilinder=np.sqrt(1./2*(Longitudinalstress**2+Loopstress**2+(Longitudinalstress-Loopstress)**2))
#VMsphere=Spherestress #von mises stress of sphere is equal to spherestress


rho=1000.   #material density
g=10. #grav acceleration

def fuselageloadcase(rho,g,R,L,t,Lift1,Lift2,Loc1,Loc2):#lift1=lift main wing-weight main wing, Loc1=location of main wing, Lift2=lift second  wing
    tL=2*R+L
    #z pointed towards the back
    #y positive down
    #discretization
    n=10
    dz=tL/n
    Acilinder=t*2*np.pi*R #material area in cilinder
    #weight distribution+lift
    wd=[]   #weight in N/m, positive downwards
    for i in range(n):
        z=i*dz
        if z<R:
            wdl=t*2*np.pi*R**2*g*rho/n*tL/R###nose weight equally distributed
        elif z<(R+L):
            wdl=Acilinder*g*rho
        else:# z<(2*R+L):
            wdl=t*2*np.pi*R**2*g*rho/n*tL/R###tail weight equally distributed
        if z<Loc1<(z+dz):
            wdl=wdl-Lift1
        if z<Loc2<(z+dz):
            wdl=wdl-Lift2
        wd.append(wdl)
    wd=wd+g*150./n    #add weight of other systems
    Vx=[]
    Vy=[]
    My=[]
    Mx=[]
    V1=0.
    for i in range(n):
        z=i*dz
        V1=V1+dz*wd[i]
        V2=0.
        M1=0.
        M2=0.
        for i in range(n):
            M1=M1+z*dz*wd[i]
            M2=M2+0.

        Vx.append(V1)
        Vy.append(V2)
        My.append(M1)
        Mx.append(M2)
    return Vx,Vy, My, Mx

def fuselagestress(R,sufuselage,Vyf,Vzf,Mzf,Myf,tf,SF,p,L):
    n=100
    tl=2*R+L
    dz=tl/n
    vMst=100000000.
    sufuselage=sufuselage/SF
    while vMst>sufuselage:
        Iyy=np.pi*R**3*tf
        Izz=np.pi*R**3*tf
        theta=0.
        vMs=[]
        xl=[]
        yl=[]
        for i in range(len(Vyf)):
            thetal=[]
            while theta<(2*np.pi):
                Qy=2*tf*R**2*np.cos(theta)    #first moment of area
                Qz=2*tf*R**2*np.sin(theta)
                ql=Vyf[i]*Qy/Iyy-Vzf[i]*Qz/Izz
                sigmal=R*(Myf[i]*np.cos(theta)/Iyy-Mzf[i]*np.sin(theta)/Izz)
                thetal.append(theta)
                theta=theta+0.5
                longitudinalstress=p*R/2./tf
                qloop=p*R
                qtot=qloop+ql
                tau=qtot/tf
                totsigma=longitudinalstress + sigmal
                vMsl=np.sqrt(totsigma**2+3*tau**2)
                vMs.append(vMsl)
            x=np.cos(thetal)
            y=np.sin(theta)
            lz=len(x)

            xl.append(x)
            yl.append(y)
        z=np.arange(0,dz*(lz+1),dz)
        vMst=max(vMs)
        tf=tf+0.001
    return tf, xl, yl, z, vMs
#print fuselagestress(4.,5000000.,[50000.,49000.],[10000.,9800.],[15000.,50000.],[15000.,60000.],0.003, 2., 800000.)
x=np.array(fuselagestress(4.,5000000.,[50000.,49000.],[10000.,9800.],[15000.,50000.],[15000.,60000.],0.003, 2., 800000., 5)[1])
y=np.array(fuselagestress(4.,5000000.,[50000.,49000.],[10000.,9800.],[15000.,50000.],[15000.,60000.],0.003, 2., 800000., 5)[2])
z=np.array(fuselagestress(4.,5000000.,[50000.,49000.],[10000.,9800.],[15000.,50000.],[15000.,60000.],0.003, 2., 800000., 5)[3])
vMs=np.array(fuselagestress(4.,5000000.,[50000.,49000.],[10000.,9800.],[15000.,50000.],[15000.,60000.],0.003, 2., 800000., 5)[4])

x,y,z  = np.meshgrid(x,y, z)

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(x, y, z,vMs)
plt.show()
